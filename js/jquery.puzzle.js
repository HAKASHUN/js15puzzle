// Generated by CoffeeScript 1.4.0
var Puzzle,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Puzzle = (function() {

  function Puzzle() {
    this._onTileClick = __bind(this._onTileClick, this);
    this.init();
  }

  Puzzle.prototype.config = {
    tileSize: 75,
    tileCount: 4,
    margin: 1,
    totalTileCount: void 0,
    boardSelector: '#puzzle'
  };

  Puzzle.prototype._ansower = [];

  Puzzle.prototype._position = [];

  Puzzle.prototype._board = [];

  Puzzle.prototype._createTile = function(count) {
    var $tile,
      _this = this;
    $tile = $('</div>');
    $tile.addClass('tile').data('tile-count', count);
    if (count === this.config.totalTileCount) {
      $tile.addClass('empty');
    } else {
      $tile.text(count).click(function(e) {
        e.preventDefault();
        return _this._onTileClick(_this);
      });
    }
    return tile;
  };

  /**
  * タイルのx, yから実際の座標(px)を取得
  * @param x
  * @param y
  * @return {Object}
  * @private
  */


  Puzzle.prototype._onTileClick = function(tileEl) {
    var currentPosition, isEmptyTile, swapTile, tileCount, totalTileCount;
    currentPosition = +$(tileEl).data('current-index');
    totalTileCount = this.config.totalTileCount;
    tileCount = this.config.tileCount;
    isEmptyTile = this._isEmptyTile;
    swapTile = this._swapTile;
    if ((currentPosition + 1) <= totalTileCount && isEmptyTile(currentPosition + 1)) {
      swapTile(currentPosition, currentPosition + 1);
      return false;
    }
    if (currentPosition - 1 > 0 && isEmptyTile(currentPosition - 1)) {
      swapTile(currentPosition, currentPosition - 1);
      return false;
    }
    if (currentPosition + tileCount <= totalTileCount && isEmptyTile(currentPosition + tileCount)) {
      swapTile(currentPosition, currentPosition + tileCount);
      return false;
    }
    if (currentPosition + tileCount > 0 && isEmptyTile(currentPosition - tileCount)) {
      swapTile(currentPosition, currentPosition - tileCount);
      return false;
    }
  };

  /**
  * タイルを初期化
  */


  Puzzle.prototype.init = function() {
    var curPos, i, positionObj, tile, _i, _len, _ref;
    this.config.totalTileCount = Math.pow(this.config.tileCount, 2);
    this._boardElement = $(this.config.boardSelector);
    this._boardElement.html('');
    this._position = [];
    this._board = [];
    _ref = this.config.totalTileCount;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      tile = this._createTile(i + 1);
      curPos = this._getPositionFromIndex(i);
      positionObj = this._getAbsolutePosition(curPos.x, curPos.y);
      $(tile).css({
        left: "" + positionObj.left + "px",
        top: "" + positionObj.top + "px"
      }).data('current-index', i + 1);
      this._position.push(positionObj);
      this._board[i] = tile;
      this._boardElement.append(tile);
    }
    return this._answer = this._board.concat();
  };

  /**
  * タイルをランダムに並び替え
  * @return {*}
  */


  Puzzle.prototype.randomize = function() {
    var ary, i, tempAry, _i, _len, _ref;
    ary = this._getShuffledArray(this._getSerialArray(this.config.totalTileCount));
    tempAry = [];
    this._boardElement.html('');
    console.log("ary: " + ary);
    _ref = this.config.totalTileCount;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      tempAry[i] = this._board[ary[i]];
      $(tempAry[i]).css({
        left: "" + this._position[i].left + "px",
        top: "" + this._position[i].top + "px"
      }).data('current-index', i + 1);
      this._boardElement.append(tempAry[i]);
    }
    this._board = tempAry;
    return ary;
  };

  /**
  *
  * @param count
  * @return {Array}
  * @private
  */


  Puzzle.prototype._getSerialArray = function(count) {
    var i, resultAry, _i, _len;
    resultAry = [];
    for (_i = 0, _len = count.length; _i < _len; _i++) {
      i = count[_i];
      resultAry.push(i);
    }
    return resultAry;
  };

  /**
  *
  * @param ary
  * @return {Array}
  * @private
  */


  Puzzle.prototype._getShuffledArray = function(ary) {
    var len, result, tempAry;
    len = ary.length;
    tempAry = ary.concat();
    result = [];
    while (len) {
      result.push(tempAry.splice(Math.floor(Math.random() * len--), 1)[0]);
    }
    return result;
  };

  /**
  *
  * @param index
  * @return {Object}
  * @private
  */


  Puzzle.prototype._getPositionFromIndex = function(index) {
    var result, tempCount;
    result = {};
    tempCount = index + 1;
    result.x = tempCount % this.config.tileCount === 0 ? this.config.tileCount - 1 : tempCount % this.config.tileCount - 1;
    result.y = Math.ceil(tempCount / this.config.tileCount) - 1;
    return result;
  };

  /**
  *
  * @param position
  * @return {*}
  * @private
  */


  Puzzle.prototype._getIndexFromPosition = function(position) {
    return this.config.tileCount * position.y + (position.x + 1);
  };

  Puzzle.prototype._isEmptyTile = function(index) {
    var tile;
    tile = this._board[index - 1];
    return $(tile).hasClass('empty');
  };

  Puzzle.prototype._swapTile = function(indexA, indexB) {
    var positionA, positionB, temValue, tempIndexA, tempIndexB;
    tempIndexA = indexA - 1;
    tempIndexB = indexB - 1;
    temValue = this._board[tempIndexA];
    positionA = this._position[tempIndexA];
    positionB = this._position[tempIndexB];
    this._board[tempIndexA] = this._board[tempIndexB];
    this._board[tempIndexB] = temValue;
    $(this._board[tempIndexA]).css({
      top: "" + positionA.top + "px",
      left: "" + positionA.left + "px"
    }).data('current-index', indexA);
    $(this._board[tempIndexB]).css({
      top: "" + positionB.top + "px",
      left: "" + positionB.left + "px"
    }).data('current-index', indexB);
    return console.log('swap', indexA, indexB, this._board);
  };

  return Puzzle;

})();

$(function() {
  var puzzle;
  puzzle = new Puzzle();
  $('#initPuzzle').click(function() {
    return puzzle.init();
  });
  return $('#randomizePuzzle').click(function() {
    return puzzle.randomize();
  });
});
